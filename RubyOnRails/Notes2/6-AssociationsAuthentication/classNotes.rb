#==========================================================================#
#            Section 6. Associations and Authentication Systems            #
#==========================================================================#










#=================================================================#
#            124. Intro to Section 6: Users/Assoc/ERD+            #
#=================================================================#

# The last couple sections covered articles
# Now we are going to focus on users

# We will make associations between users and articles 

# Users table will have 4 fields
#   users
#     id
#       unique id generated by rails
#     username
#       username a user would login with
#     email
#       an email for each user
#     password
#       a password that a username can login with
#       (remember bcrypt?)

# We will update the articles to have an author
# The author will be represented by the user_id
#
# The user_id is what is called a foreign key
# It tracks the id of items in the users table to create associations between articles and users

# The id column in the users table is called a primary key (just like id in articles is the primary key)

# The association between the two tables will be a one to many
#  This makes sense because one user can create many articles but each article can only have 1 user
#
# This can be visualized with an Entity Relationship Diagram (ERD)
#
#  Users                        articles
#   id        int                 id            int
#   username  string    1 --> *   title         string
#   email     string              description   string
#   password  string              user_id       int

# More information can be found here: https://guides.rubyonrails.org/association_basics.html

# The association we are interested in is the has_many association















#=====================================================================#
#            125. One to Many Associations demo w/ console            #
#=====================================================================#

# We will go through a quick demo of a one to many association

# MAKE SURE YOU ARE IN TEST APP OR SOMETHING NOT ALPHA BLOG

# First we have to make a users resource (table) using a scaffold generator
# Double check that you are in test app

# Generate Scaffold
#   $rails generate scaffold User username:string

# Now in test app you should be able to see the create users migration
# you can see that it will create an entry with a username and a timestamp

# Let's run the migration file
#   $rails db:migrate

# Now we can get on the rails console
# Because we used a scaffold the model is available to us

# Let's create a couple of users
#   $User.create(username: "user1")
#   $User.create(username: "user2")

# Now we have to create an association between users and articles
# First we will need a user_id field in our articles table
#  we do not have this so we will have to add it

# Exit console

# We have to create a new migration to do this so
#   $rails generate migration add_user_id_to_articles

# We will have to go in and add to the change method in the file that was generated
# Add the following:
#   def change
#     add_column :articles, :user_id, :int
#   end
#
# This will add a new column to the articles table called user_id of type int

# Now we have to run the migration
#   $rails db:migrate

# We can get on the rails console again to confirm the column was added

# We can see that there is a user_id attribute for the articles w/ Article.all but it is nil for both

# Now we have to make the association between users and articles by adding code to the models
# Since a user can have many articles we will specify that for users first
# In app/models/user.rb:
#   has_many :articles

# Now in the article.rb model we have to specify that the user_id belongs to a user
# We can add that with the line:
#   belongs_to :user

# That should be all we need to make the association between users and articles

# Open console to test 
#   $user1 = User.first # get a use to test
#   $user1.articles => Empty array
#
# The empty array and not an error means that it knows there can be associations there but we have not made any yet

# We can add users to articles when we create them 
#   $Article.create(title: "Connecting Users", description: "Connecting users with articles", user_id: user1.id)
#
# Now when we call:
#   $user1.articles
#   => #<ActiveRecord::Associations::CollectionProxy 
#      [#<Article id: 3, title: "Connecting Users", description: "Associating users with articles", 
#      created_at: "2020-09-05 09:44:09", updated_at: "2020-09-05 09:44:09", user_id: 1>]>

# We can see that our databse can tell which articles belong to users based on the article's user_id

# We can also directly create new articles using the user object
#   $article = user1.articles.build(title: "some new article", description: "description of the article")

# Another way we can create a new article or assign a user to an existing article
# We can use the shovel operator to do this
#   $user2.articles << Article.first
#
# Now user2 has an article in their articles list when they didn't before















#=========================================#
#            126. Create Users            #
#=========================================#

# Now that we have practiced let's add users to the alpha-blog app.
# This time we won't use a scaffold generator

# We are going to start with the users table only have username and email fields; not password

# First let's explore git branches
# Git branches can be used to add new features without affecting the master branch of code
# With a branch you can make an alt copy of your app 
# when it is complete and functional merge it back into the master branch

# We always want the master branch to be something that is deployable to production
# First make sure you are in alpha-blog app
# To create a branch:
#   $git checkout -b create-users-table-model
#
# We can see all the branches of a project with the command:
#   $git branch
#
# The branch we are currently in will have a * next to it

# To switch between branches use git checkout
#   $git checkout master
#
# This will switch back to the master branch

# Make sure you are in the create-users-table-model branch before continuing

# Now let's start creating the users table
# To do that first we need to generate a migration file
#   $rails generate migration create_users
#
# Now we have to edit the migration file to give the columns we need
# Use the create_articles migration file as a reference and add a username and email column to the table
# Also add timestamps
# By the time you are done the migration file should look like this:
#   class CreateUsers < ActiveRecord::Migration[6.0]
#     def change
#       create_table :users do |t|
#         t.string :username
#         t.string :email
#         t.timestamps
#       end
#     end
#   end

# Now that the migration file is finished we can run it:
#   $rails db:migrate

# Now we have to create the user model
# Create app/models/user.rb
# Add the User class (Look at article.rb for reference)
# Class should look like:
#   class User < ApplicationRecord
#   
#   end
#
# That should be enough for us to start testing out connection to the users table from the console

# Double check that the table was created successfully (in rails console)
#   $User.all # =>[]
#   $User # =>User(id: integer, username: string, email: string, created_at: datetime, updated_at: datetime)

# Let's test all 4 crud actions really quick to make sure they are all working
#   Create
#     $User.create(username: "user1", email: "user1@email.com")
# 
#   Read
#     $user = User.first
#
#   Update
#    $user.email = "user1!@newemail.com"
#    $user.save
#
#   Delete
#     $user.destroy

# Everything is working as expected so let's make a commit right now
# Before pushing let's merge our changes with our master branch
# First switch back to the master branch:
#   $git checkout master
#
# Notice that the migration file and user model file are now gone
# This is because those were created on the feature branch and do not exist in the master branch
# To merge the two branches:
#   $git merge create-users-table-model
#
# Now the code from the feature branch is merged into the master branch 
# Both the migration file and the user model are both in the master branch
#
# If we were working on code in our feature branch and we knew the master branch was being updated we would merge the master into the feature
# This would keep our feature branch up to date over the rest of the app and resolve any conflicts early on
# We would have to do this before merging the feature branch into master if the master branch had been updated










#==========================================================#
#            127. Instrutor Notes: Create Users            #
#==========================================================#

# To create a git feature branch, you can use:

# $ git checkout -b nameofbranch

# To create a feature branch named create-users-table-model:

# $ git checkout -b create-users-table-model

# To view list of branches:

# $ git branch

# To move to master branch:

# $ git checkout master

# To move back to already created feature branch:

# $ git checkout create-users-table-model

# Important to remember is to always have master branch deployable to production and work on all new features and additions in feature branches

# To create a migration to create users table:

# $ rails generate migration create_users

# Then within the migration file, add in the following code within the create_table block to add the username, email and timestamps columns (created_at and updated_at):

# t.string :username
# t.string :email
# t.timestamps
# To run the migration file and create the users table:

# $ rails db:migrate

# Now create the User model file. Add a user.rb file under app/models folder and fill in the following:

# class User < ApplicationRecord
# end
# Then you can test out the mode using the rails console. You can start the rails console and try out the following commands (or other commands as you choose):

# $ rails console
# User.all
# User
# user = User.create(username: "test", email: "test@example.com")
# user = User.create(username: "test2", email: "test2@example.com")
# # To grab first user and update their email address:
# user = User.find(1) 
# # OR
# user = User.first
# # update the email
# user.email = "test3@example.com"
# user.save
# # To destroy user with id of 2 (if that id exists in your users table, or select
# # an appropriate id that does exist
# user = User.find(2)
# user.destroy
# To make a commit of the changes made in the feature branch, from the feature branch itself:

# $ git add -A
# $ git commit -m "create users table and user model"
# To merge the changes made in the feature branch to the master branch first switch to master branch:

# $ git checkout master
# $ git merge create-users-table-model 
# # or the name of your feature branch instead of create-users-table-model
# To push your master branch to your online repo:

# $ git push origin master

# If you want to discard/delete a feature branch that is no longer needed and has been merged to master branch already (not covered in video):

# $ git branch -d nameofbranch

# To delete a feature branch that is no longer needed but has NOT been merged to master (not covered in video):

# git branch -D nameofbranch















#=================================================#
#            128. Add User Validations            #
#=================================================#

# We want to add validation to the User fields (like username length and that email is a valid email format)

# To do that let's work in another feature branch
# Make sure you are in alpha-blog directory
# Then create a new branch:
#   $git checkout -b user-validations

# Here is what we want users to look like when we are done:
#   Resource
#   - Users - Create users table and model (done)
#           - Add validatons
#             * username must be present and unique, min 3, max 25
#             * email address must be present and unique, max 105
#             * email must be valid email format, check with email regex
#
#   Associations
#   - One to many
#       Between users and articles
#
#   REST for users
#
#   Authentication
#   - Login using secure password
#
#   Restriction of actions
#   - Based on logged in/logged out state
#
#   Security
#   - Admin user functionality and access level

# Let's take care of the user validations now
# Open up the user model file (app/models/user.rb)
# We can see validations that are provided by rails for us at: https://guides.rubyonrails.org/active_record_validations.html

# We are going to use the uniqueness validation from the link above
# To validate the usename field (without uniqueness)
# Add the following to user.rb:
#   validates :username, presence: true, length: {minimum: 3, maximum: 25}
#
# Test creating a user with out a username, less than required character length, and greater than allowed length in rails console
#   $user = User.new(username: "", email: "")
#   $user.save
#   =>false
#   $user.username = "a"
#   $user.save
#   =>false 
#   $user.username = "j" * 30
#   $user.save
#   =>false
#
# Note that you can use user.valid? to see if the user object can be saved
# You can also use user.errors.full_messages but only after using user.save or user.valid?

# Now to do the same for email
# We can just copy the line and change :username to :email and change the character requirement

# Next we want to add uniqueness for the username
# All we have to do is add the following to our validation:
#   uniqueness: true

# Save and reload rails console
# Test this by making a new user and saving it to the databse
# Then make another new user with the same username and try to save it to the database
# See what any errors are with 
#   $user.errors.full_messages
#   =>["Username has already been taken"]

# This is pretty close but we also don't want the usernames to be case sensitive
# we want aaa to be treated the same as AaA
# We can change our uniqueness: true method from earlier to uniqueness {case_sensitive: false}
#
# Test to make sure that you can't add the same username even when you change the case
#
# If that works add the same line to to the email validation
# At this point the User model should look like:
#   class User < ApplicationRecord
#     validates :username, presence: true, 
#                         uniqueness: {case_sensitive: false}, 
#                         length: {minimum: 3, maximum: 25}
#     validates :email, presence: true, 
#                       uniqueness: {case_sensitive: false}, 
#                       length: {maximum: 100}
#   end

# Now we are going to use REGEX (regular expressions) 
# They take strings and run a test on them to see if they pass
# This can be used to parse and verify whether different strings contain the things that are expected
# For example an email is expected to have 3 parts:
#   user@email.com
# 
# Regex will take the string and verify that it has the patterns that a normal email will have
# There is a short way and a long way to do this
# The short way works good enough for our purposes so that is what we will use

# Add the following line above the email validation:
#   VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
#
# Notice that our variable is in all caps
# This is because it is not a variable it is a constant
# We will not be changing the regex for verifying our email within any methods of our app 
# So we can set it to constant just to be certain that it won't change accidentally

# Now we have to add this regex to our email validation
# To do that add the following to the end of the email validation:
#   format {with: VALID_EMAIL_REGEX}

# There is a site we can use to test out our regular expressions called rubular.com
# We can plug in our regular expression and test different strings to make sure they pass or fail

# Now let's test it in our app
# In rails console
# Make a new user with a valid username and an email that does not match user@email.com patter
#   $user = User.new(username: "user2", email: "test.com")
#   $user.valid?
#   =>false
#   $user.errors.full_messages
#   =>["Email is invalid"]

# Now our validation has successfully been added 
# Now our code should look like:
#   class User < ApplicationRecord
#     validates :username, presence: true, 
#                         uniqueness: {case_sensitive: false}, 
#                         length: {minimum: 3, maximum: 25}
#     VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
#     validates :email, presence: true, 
#                       uniqueness: {case_sensitive: false}, 
#                       length: {maximum: 100},
#                       format: {with: VALID_EMAIL_REGEX}
#   end

# Go ahead and make a commit
#
# Then merge those changes with master
#   $git checkout master
#   $git merge user-validation










#==================================================================#
#            129. Instructor Notes: Add User Validation            #
#==================================================================#

# Validations for User class:

# - username must be present and unique, length between 3 and 25 characters

# - email must be present and unique, length max of 105 characters

# - validate email format using regex (regular expression)

# You can find the code added to the user model during the video here: https://github.com/udemyrailscourse/alpha-blog-6/commit/1834571a5a219fb3347f0a3d658a7a8e89607a78

# The ruby regular expression used to match the format of valid email addresses is listed below.

# /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i















#====================================================#
#            130. One to Many Association            #
#====================================================#

# Now we that we have the users table and model we can add the association between users and articles

# To do that we need to add the user_id field to the articles table
# This will be a foreign key that references an id in the users table

# First let's start on a new feature branch
#   $git checkout -b user-articles-association

# Now to generate a migration
#   $rails generate migraation add_user_id_to_articles

# Now to go into the migration file and add our new column 
# The file is in db/migrate/yyyymmddhhmm_add_user_id_to_articles.rb
#
# First ot add the new column:
#   add_column :articles, :user_id, :int
#
# This says we are adding a new column to the articles tables called user_id and it will hold ints

# Now to run the migration file
#   $rails db:migrate
#
# Now we can get on the rails column to see the changed table
# With Article.all we can see that there is now a user_id field on all of our entries with a value of nil

# With our association we want to be able to find who created an article by referencing the articles user
# For example we want to find who wrote an article by using something like article.user 
#  which will look at the user_id and return the user with a matching user id

# To add the association we have to change the user model and the article model
# Let's start with the user model
# At the top of the class add:
#   has_many :articles
#
# Then in the articles model:
#   belongs_to :user

# Now if we save and reload the console we can tell there is an association by running:
#   $article = Article.first
#   $article.user
#   =>nil
#
# This means that it isn't unexpected that there should be a user but one hasn't been assigned
#
# We can also do the reverse
#   $user = User.first
#   $user.articles
#   =>[] 
#
# Returns an empty array because there are no articles holding this user id

# Now let's assign the article we have to a user
# We can do that with the shovel operator we discussed earlier
#   $user.articles << article
# 
# Now the article has a user_id of 2 and belongs to that user
#   $user.articles
#   =>[] #array with all user's articles inside
#
#   $article.user
#   =>{} #returns user object with user details
#
#   $article.user.username
#   =>user1 # returns name of user associated with article

# Now that we have created this association we cannot have an article created without giving it a user
# To test that try making an article without a user
#   $article = Article.new(title: "title", description: "description of article")
#   $article.valid?
#   =>false
#   $article.errors.full_messages
#   =>["User must exist"]

# We can also see that we run into this error if we try to create a new article in the browser

# For now we need to update the creation (and edit) function for our articles and hardcode an assigned user
# Then later when we create user authentification only logged in users will be able to create articles
#  it will then assign the logged in user as the user of the article

# To hardcode:
#   in articles_controller.rb
#   after we create the @article instance variable we just assign it a user
#     @article.user = User.first
#
# This code will work as long as there are any users in the database

# Since articles that already exist don't have a user they can't be updated or edited so we will assign them a user from the console
# In rails console
#   $Article.update_all(user_id: User.first.id)
#
# This will go through all existing articles and change their user id to match the first user id in the users table

# Now we can edit articles again
# You can test this in the browser

# Since our one to many association is set we can make a commit and merge back with the master branch










#======================================================================#
#            131. Instructor Notes: One to Many Association            #
#======================================================================#

# All the code changes made in the previous video can be found in the commit for this video here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/f469dba9845c0f9fda9cf495d997ee0fd366371d

# To generate a migration to add the user_id column to articles table, you can use the command below:

# $ rails generate migration add_user_id_to_articles

# Then within the change method fill in the code specifying the change:

# add_column :articles, :user_id, :int

# Run the migration file to effect the change:

# $ rails db:migrate

# To form the association among the models, add the following line to article.rb model file:

# belongs_to :user

# And add the following line to user.rb model file:

# has_many :articles

# Ensure you have a couple of users in your users table created using the rails console. Then add in a line in the create action to temporarily grab and hardcode a user to each article that's created:

# def create 
#   @article = Article.new(article_params) 
#   @article.user = User.first # <--- Add this line
#   if @article.save 
#     flash[:notice] = "Article was created successfully." 
#     redirect_to @article 
#   else 
#     render 'new' 
#   end 
# end















#=======================================================#
#            132. Show User Info In Articles            #
#=======================================================#

# Now we want to update the articles index and the show page to show the user associated with the article

# To do that lets start with articles/index.html.erb:
#   Replace the hardcoded author name with:
#     <%= article.user.username if article.user %>

# Then in articles/show.html.erb
#   Replace the hardcoded author name with:
#     <%= @article.user.username if @article.user %>

# Now usernames associated with articles will be displayed on the articles index and article show page










#=========================================================================#
#            133. Instructor Notes: Show User Info In Articles            #
#=========================================================================#

# # Add the following line of code where you had previously hard-coded the creator name for each article in the index.html.erb file under app/views/articles folder:

# by <%= article.user.username if article.user %>

# And for the show view in the show.html.erb template:

# by <%= @article.user.username if @article.user %>

# The code updates made during the video can be found in the commit here: https://github.com/udemyrailscourse/alpha-blog-6/commit/c7e1b60ab508bec967877762a0222a384f995a6d















#===========================================================#
#            134. Alter Object State before_save            #
#===========================================================#

# We are going to cover the before_save method
# This will allow us to change the objects state right before we submit it to the database

# We want to use this method on the email field
# This is because users can submit emails with random capitalization
#  but for emails capitalization doesn't matter and we want them all lowercase

# Let's take a look in console
#   $User.create(username: "janedoe", email: "JanEDoE@example.com")
#
# When saving user the email retains capitalization

# To fix this we can add before_save to the user model
# Before any other methods and before has_many method
#   before_save {self.email = email.downcase} 
#
# This is saying take each object and set it's own email field to be the downcased version of itself

# Now if we try to make the user above
#   $User.create(username: "janedoe", email: "JanEDoE@example.com")
#   =><User id: 4, username: "janedoe", email: "janedoe@email.com", created_at: "2020-09-06 03:01:30", updated_at: "2020-09-06 03:01:30">
#
# Notice that the email field is lowercase because ran our downcase method on it before saving it










#=============================================================================#
#            135. Instructor Notes: Alter Object State before_save            #
#=============================================================================#

# In the video we used the before_save method to change emails entered to lowercase before saving them to the database. 
# To accomplish this we added the line before to our user model:

# before_save { self.email = email.downcase }

# The code change made in the video can be found in the commit here: https://github.com/udemyrailscourse/alpha-blog-6/commit/02ad866b53febcee81c760fb118aa6124bea4692















#================================================#
#            136. Add Secure Password            #
#================================================#

# We need to build an authentication system for our app
# This way users can log in to create new articles or edit/delete their own articles
# There are gems that can accomplish this 
# In order to understand what those gems are doing we are going to build our own from scratch

# We will be using bcrypt again to hash user entered passwords and verify authentication
# You can see that bcrypt is listed in the Gemfile but is currently commented out 

# How does saving user passwords work and how do they authenticate?
# Let's say we have a user with a username and email
# The user needs to add a password
# They will choose their password and it is run through bcrypt to hash the password
# Then it saves that hashed string
# There is no way to know what that string decrypts to without knowing what the orginal string was
# That way if our databse is compromised they will have no way of knowing what a users password was

# Now let's implement this in our app
# Step one is to install the bcrypt gem
# Go to the Gemfile and uncomment out the bcrypt line
# Save and then run:
#   $bundle install
# 
# Now bcrypt should be installed and ready to use in our app

# Now we have to add has_secure_password to our model
# This should go underneath both of our validations

# The last step is to add the password digest field to the user table
# In order to do that we will need to generate a new migration
#   $rails generate migration add_password_digest_to_users

# Now in our migration file we just made:
#   add_column :users, :password_digest, :string

# Now to run the migration
#   $rails db:migrate

# Now that the column is added to our table let's go to the rails console and check
#   $User.all
#   
# We can see that there is a new field called password_digest that is nill
# The virtual attribute for password_digest is password so we can use that to refer to this new column

# We will first take a string and turn it into it's hashed version using Bcrypt
#   $BCrypt::Password.create("password")
#   =>hashedversionofpassword
# 
# If we do the same thing again we will get a different string
# This is happening because of "salt"
#   salt is a random piece of text that is added to the password before it is hashed
#
# BCrypt has the mechanism in place to read that salt when converting a text to a hash

# Let's set the hashed password equal to a password variable
#   $password = _ (underscore represents whatever the last returned value was)
#
# Now if we run password.salt
# It will return the salt of the password to you 

# BCrypt is able to take that salt and a provided string
# Run both the salt and the string to the algorithm
# And see if it matches the hash stored as the users password in the database
# If it does match the user can login and if it does not then the password they provided was wrong
# Rails uses a method called authenticate to do this
#   $user = User.last
#   $user.password = "password123"
#   $user.save
#   $User.all
# 
# We can see that the password digest is filtered but it is no longer nill
#   If you run:
#     $User.last.password_digest
#     
#   You will get the hashed form of their password

# Now let's explore the authenticate method with this user
#   $user = User.last
#   $user.authenticate("wrongpassword")
#   =>false
#   $user.authenticate("password123")
#   =>(returns user object)

# Our flow will be a user will log in with their username or email an password
# We will search our databse for that username or email
# We will compare the password using .authenticate
# If the user object is returned then the login was successful










#==================================================================#
#            137. Instructor Notes: Add Secure Password            #
#==================================================================#

# 3 step process to add auth system functionality from the back-end.

# Step 1) Add bcrypt gem:

# In the Gemfile uncomment the line that lists the gem:

# gem 'bcrypt', '~> 3.1.7'

# Then run $ bundle install to install the gem in your app.

# Step 2) Add has_secure_password to your user model. Add the line below in your user.rb model file:

# has_secure_password

# Step 3) Create a migration file to add the password_digest column to the users table.

# $ rails generate migration add_password_digest_to_users
# Then pull up the migration file and fill in the column details within the def change method:

# add_column :users, :password_digest, :string
# Save the file and run $ rails db:migrate to make the change to the table

# You can test out the functionality from the console by adding passwords to a couple of your existing users and verifying them using the authenticate method. A sample progression of commands from the console could be like below:

# user = User.last
# user.password = "password123"
# user.save
# The commands above will add the hashed version (with salt) of the string "password123" to the user's record.

# Then you can authenticate and test the password for the user like below:

# user = User.last # (or User.find(enter id of user here))
# user.authenticate("password123") # This, being the correct password will return the user object
# user.authenticate("enterincorrectpassword") # This, being an incorrect password, will return false
# You can find all the code changes made in the video in this commit: https://github.com/udemyrailscourse/alpha-blog-6/commit/e6f2b5036c455d6987d45fa30d26d0b6e7533e26















#=================================================#
#            138. New User Signup Form            #
#=================================================#

# So far we have only been able to add users from the console in the backend
# Now we want to add the ability for users to sign up directly in the browser
# This will require a route and a form

# This form will look very similar to the articles creation form
# Eventually we will want users to be able to edit their profile details so we will have to

# First make a new feature branch
#   $git checkout -b users-signup

# The first thing we want is a new route to the signup page
# We will use the /signup route
#
# In order to get that we have to build the route

# In config/routes.rb
#   get 'signup', to: 'users#new'
#
# This will route to the users_controller (not made yet) and look for the method new
# It will also look for a new view in the users views folder 

# Now we have to create a users controller
# Create app/controllers/users_controller.rb
# Add the UsersController class (just like in pages_controller.rb) and new method
#   class UsersController < ApplicationController
#     def new
#   
#     end
#   end

# We need to create a form template 
# We can use new articles form as a reference

# create the folder and file app/views/users/new.html.erb
# Then create a _from partial in the users folder to use as our signup form
# Since the articles form is pretty close to what we need we can copy that form and adjust it as needed
# The important thing is that both forms will be using a local model to back them
# We will also have to initiate a @user instance variable in our users_controller
#   add the following to the new method in users_controller
#     @user = User.new
#
# Edit the form code to fit our needs
# When finished it should look like this:
#   <div class="container">
#     <div class="row justify-content-center">
#       <div class="col-10">
#         <%= render 'shared/errors' %>
#         <%= form_with(model: @user, class: "shadow p-3 mb-3 rounded", id: "create-article-form", local: true)  do |f| %>
#           <div class="form-group row">
#             <%= f.label :username, class: "col-2 col-form-label" %>
#             <div class="col-10">
#               <%= f.text_field :username, class: "form-control shadow rounded", placeholder: "Enter a username" %>
#             </div>
#           </div>
#  
#           <div class="form-group row">
#               <%= f.label :email, class: "col-2 col-form-label" %>
#               <div class="col-10">
#               <%= f.email_field :email, class: "form-control shadow rounded", placeholder: "Enter your email address" %>
#               </div>
#           </div>
# 
#           <div class="form-group row">
#               <%= f.label :password, class: "col-2 col-form-label" %>
#               <div class="col-10">
#               <%= f.password_field :password, class: "form-control shadow rounded", placeholder: "Choose a password" %>
#               </div>
#           </div>
#
# 
#           <div class="form-group row justify-content-center">
#             <%= f.submit class: "btn btn-success", id: "btn-submit-form" %>
#             <%= link_to 'Cancel and Return to Articles Listing', articles_path, class: "btn btn-danger", id: "btn-cancel form" %>
#           </div>
#         <% end %>
#       </div>#
#     </div>
#   </div>

# There is a problem we have an issue when trying to render 'shared/errors'
# The problem is that the errors partial refers to the @article instance variable
# That used to make sense since we only needed it to handle errors related to articles
# However now we want to change it so it will work for both articles and users
# We can do that by changing at @article to obj in this file

# Now move to the articles _form partial where we call this errors page
# We can add to that line to let the program know to pass in @articles as obj in the errors page
# we didn't have to let it know before since we specified @articles in the errors page previously
# Edit the line that displays the errors to be:
#   <%= render 'shared/errors', obj: @article %>
#
# We also have to do the same to the users form that we did to the articles form to pass in a user instead of an article

# Now the issue is that there is an undefined method for users_path
# This is because the form is looking for where to submit to but users_path hasn't been defined yet
# The form is going to look for a user path defined to submit the post request to in routes.rb
# We can add that with:
#   post 'users', to: 'users#create'

# Now when we load the page the sign up form should display

# We can do this in a better way though since we know we want users to have all of the restful routes
# To do that we can add users as a resource instead
# Change the line above to:
#   resources :users, except: [:new]
#
# This will ensure we don't get the new route for users (since we have already defined it) but we do get all of the others










#===================================================================#
#            139. Instructor Notes: New User Signup Form            #
#===================================================================#

# The code changes made in the previous video can be found here: https://github.com/udemyrailscourse/alpha-blog-6/commit/57eb602a0e582d31e6ecc19efbddf3681745a2be

# To add the route for the new user signup page and the rest of the restful routes separately, add the following two lines to your routes.rb file:

# get 'signup', to: 'users#new'
# resources :users, except: [:new]
# The changes made in the video in addition to the routes above are listed below (reference the commit for the specific code):

# - Create users controller.

# - Add new action along with initiating a new user instance variable.

# - Create a users folder under app/views and add the new.html.erb template.

# - Add a form partial, _form.html.erb, in the same folder.

# - Update app/views/shared/_errors.html.erb and replace @article references with obj.

# - Update app/views/articles/_form.html.erb and add obj: @article when rendering the errors partial.

# Test out the form by going to /signup page and ensure it shows up.















#========================================================#
#            140. Create New Users (back-end)            #
#========================================================#

# Now that we have the front end of our new users sign up complete
# Now let's get the back end set up to accept the form details and create a new user entry

# Right now if we try to create a new user we will get the following error:
#   The action create could not be found in the users controller
# So we have to define a create method in the users_controller.rb
#
# If we put a byebug stop in that method and submit a form
# The page will pause once we get inside the create method
#
# We can then use the params command in the server tab of our terminal to see what params are currently available to use
# We can see that there is a username, email, and password (plaintext)
#
# We can select the user details with:
#   $params[:user]

# Now we need to whitelist these parameters just like we did for new articles and save them to the users table
# Add the following line to the create method in the users_controller
#   @user = User.new(user_params)
#   if @user.save
#     flash[:notice] = "Welcome to the Alpha Blog, you have successfully signed up"
#     redirect_to articles_path
#   else
#     render 'new'
#   end
#
# We also have to define the user_params method we passed into User.new (make a private method)
#   private
#   def user_params
#     params.require(:user).permit(:username, :email, :password)
#   end

# Now let's test it out in the browser and check if users are created with our rails console
# Create a valid user in the browser
# Once you see the pop up saying creation successful open rails console
#   $User.all
# 
# See the user we just created listed!

# Let's customize the welcome message to make it a little more personal
# Where we set the flash notice in user params display the username in the welcome message
# The flash notice line should now look like this:
#   flash[:notice] = "Welcome to the Alpha Blog #{@user.username}, you have successfully signed up"
# 
# Create a new valid user to test that the message shows up correctly

# Now what about validation error messages?
# They work as expected except it says the "The following errors have prevented the ARTICLE from being saved"
# We want to change that to still say article for articles but to say user when creating a user

# We will need to change _errors partial in the shared views folder
# We can replace the word article in the alert-heading to:
#   <%= obj.class.name.downcase %>
#
# Now it will say the correct name for what is being saved
# You can test this for both users and articles

# Now we want to change the button on the user form from saying "Create user" to "Sign Up"
# We will have to edit the _form partial in the users views folder
# Change the submit button line to the following:
#   <%= f.submit "Sign Up", class: "btn btn-success", id: "btn-submit-form" %>

# For the last change let's add a sign up link to the home page
# In app/views/pages/home.html.erb
# Change the line with the sign up button to be embedded ruby that links to the signup page
# After you are done it should look like this:
#   <%= link_to "Sign Up!", signup_path, class: "btn btn-primary btn-lg" %>
#   
#   Delete the old button

# Now our signup process is complete

# We can make a new commit and merge back into master branch










#==========================================================================#
#            141. Instructor Notes: Create New Users (back-end)            #
#==========================================================================#

# The code changes made in the previous video can be found here: https://github.com/udemyrailscourse/alpha-blog-6/commit/30ed763aa9d01c4bb308ee9c5bbc8ef8cae8f6dc

# Summary of changes made (refer to the commit link for specific code):

# - Add create action and user_params method in users controller.

# - Update shared errors partial to display the appropriate class name (instead of hard-coded article).

# - Link the "Sign up!" button in the home page (app/views/pages/home.html.erb) to go to this new signup path.

# You can test out the functionality by signing up a few users from the browser and then ensuring their presence in the users table (you can check this using the rails console).















#=======================================#
#            142. Edit Users            #
#=======================================#

# Now we will add the ability for users to edit their accounts from the browser
# It will look just like the new user form except because it will use the same form partial
# The only real difference is the button text will be different

# Let's start in a new feature branch
#   $git checkout -b users-edit

# Then let's get the edit route from rails routes
#   $rails routes --expanded  | grep edit
#
# The | grep edit will only return results that contain 'edit' in them
# This will give us the result we are looking for:
#   Prefix            | edit_user
#   URI               | /users/:id/edit(.:format)
#   Controller#Action | users#edit

# We see the path is edit_user_path

# Let's play with a user without the password functionality to test this route and one that was added after

# Let's try to visit this user's user edit page with the URL provided from rails routes

# We can see that there is a problem because the edit action is not in the controller
# Let's add the edit function to the user_controller
# It will be similar to the one in articles because we have to find the user based on the user's id

# Go ahead and add a method for edit and update to the users_controller.rb
# Now we will have to specify which user we will be working with within the edit method
# Add the following line: (just like articles used to be, we will extract to a private method later)
#   @user = User.find(params[:id])
#
# Now when we reload rails complains that we are missing and edit view

# So let's create the edit view
# Create app/views/users/edit.htlm.erb
# In the new edit page add the following lines:
#   <h1 class="text-center mt-4">Edit your profile</h1>
#   <%= render 'form' %>
#
# This will tell the page to render the same form as the new user page

# Now the form shows up and username and email field are prefilled from the params that were passed in
# The problem is that the button says sign up since it was added in the form partial
# However for the edit user page we want it to say update profile
# The way we can do that is, in the form where we assign "sign up" to the f.submit button
# We can test if this is a new (non-existent) user, if it is show the sign up text
#   If it is an existing user show update profile text
# To do that change the f.submit line to the following:
#   <%= f.submit(@user.new_record? ? "Sign Up" : "Update Profile", class: "btn btn-success", id: "btn-submit-form") %>
#
# This will use a tertiary operator to display the text we want based on whether or not this is a new user

# Now the button shows what we want but nothing happens when we click on it
# This is because our update method is empty

# Let's build the UsersController#update method
# Use the following for the update method:
#   def update
#     @user = User.find(params[:id])
#     if @user.update(user_params)
#       flash[:notice] = "Your account information was successfully updated"
#       redirect_to articles_path
#     else
#       render 'edit'
#     end
#   end
#
# This will assign the current user from params as the user instance variable
# It will try to update first requiring and whitelisting the params to be updated
# If it is successful it will save the flash notice which will show on the next page that loads
# Then it will redirect to the articles index page
# If it is unsuccessful it will re-render the same user's edit page

# Now we get the error that the password can't be blank, which is good because we are editing a user without a password
# For now enter a password and update
# It should update successfully and redirect to the articles page

# Now let's try it on a user who already had a password saved
# If we try to edit a user with a password already we don't have to have anything in the password field since a password does exist already

# Our user edit functionality is working like we want so let's make a commit
# Don't forget to merge to master










#=========================================================#
#            143. Instructor Notes: Edit Users            #
#=========================================================#

# All the code changes made in the video are available here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/e247a7b0d8e52ddd71ac0571a2cb1d6cae2e1906

# To look for a specific keyword in search results from a command issued in the terminal, you can use the pipe operator followed by grep. In the video we looked for 'edit' from rails routes using the command below:

# $ rails routes --expanded | grep edit

# Summary of the changes made to add the edit existing user functionality are listed below (check out the repo for specific code):

# - Add the edit and update actions in users controller.

# - Add the edit.html.erb template under app/views/users folder.

# - Update the form partial under app/views/users folder to accommodate different button text to display based on if the record being worked on is a new record (new template) or existing record (edit template).















#========================================================#
#            144. Show User and Profile Image            #
#========================================================#

# Now we are going to add the show users page
# The completed page will have "User's profile" with the username showing in the heading
# Below that there will be a photo for a profile image
# After that it will list all the articles by the user

# First let's make a feature branch

# The user profile url will look like /users/id (with id being the user id)

# Let's try to visit a profile that does exist and see what happens now

# We see that the action show was not found in the users controller
# That means we have to make a show method and users show view
#
# Add the show method to the users_controller.rb and create the users show view
#   In the show method initial the @user instance variable (the same way we did for edit and update)
# Now we have a page that loads, we just have to build the page

# Add the headline and pass the @users.username variable into the heading

# Now to add the profile image
# We are going to use a service called gravitar
# It is provided by wordpress
# It is a plugin to our website that associates a profile photo with an email address
# After a user signs up and provides their email address our site will ask Gravitar if there is a photo associated with that account
# If there is then the appropriate photo will load
# If not there is a generic gravitar icon that will load instead

# To use this we have to send the email address to gravitar as an MD5 hash
# More info here: https://en.gravatar.com/site/implement/

# Let's get on rails console to test how this works
#   $email_address = "email@gmail.com"
#
# To create a hash of this we have to use the following line:
#   $hash: Digest::MD5.hexdigest(email_address)
#
# Now we can see the MD5 hashed version of our email address
# Then to retrieve the image we are supposed to use:
#   $image_src = "https://www.gravatar.com/avatar/#{hash}" (replace hash with the hash in console since we can't uses embedded ruby there)
#
# If we visit that link we can see the profile picture associated with that hashed email
# We can also adjust the size of the photo by adding a size parameter to the url
# At the end of the url add:
#   ?s=200
# 
# This will give us a bigger image

# Now that we can form the url in the console we can transfer that code to a method to fetch the photo
# We can call that method from the show view
# in the show view use embedded ruby to add a gravatar_for method and pass in the current user as an arguement
#   <%= gravatar_for @user %>

# Now we have to define this method 
# For methods that we add to views we can define them in the helpers folder
# We will add the gravatar_for method to app/helpers/application_helper.rb
# First define the gravatar_for method
# Then get the email address and assign it to a variable
# After that get the hash of the email address
# Then build the url using that email address and return it to the view
# These steps should be identical to what we did in the console
# Then we want to pass the gravatar url into an image tag and return the image tag (it will return automatically since it is the last line)
#   We can set an alt attribute of the username in case there is an issue with gravatar servers or something
# When finished the method should look like this:
#   def gravatar_for(user)
#     email_address = user.email.downcase # downcase isn't necessary since emails are already downcased but just in case
#     hash = Digest::MD5.hexdigest(email_address)
#     gravatar_url = "https://www.gravatar.com/avatar/#{email_address}"
#     image_tag(gravatar_url, alt: user.username)
#   end

# If we reload the user page we can see that we now have an image that shows up but it is small and all the way to the left
# Let's work on the size by editing the url to have a size parameter (like we did earlier)
# In order to keep the page dynamic we can pass in the size of the image as an option in the method
# Then within the method set size equal to options[:size] (if not specified it will be 80)
# Finally add "?s=#{size}" to the end of the url
# When finished the method should look like this:
#   module ApplicationHelper
#     def gravatar_for(user, options = {size: 80})
#       email_address = user.email.downcase
#       hash = Digest::MD5.hexdigest(email_address)
#       size = options[:size]
#       gravatar_url = "https://www.gravatar.com/avatar/#{hash}?s=#{size}"
#       image_tag(gravatar_url, alt: user.username)
#     end
#   end
#
# Now in our show page where we call the gravitar method we can pass in our size arguement
#   <%= gravatar_for @user, size: "200" %>

# Now that the image is showing we can work on centering it
# Luckily this is another thing bootstrap has built in (search bootstrap images)
# We can use the classes .rounded and put the img tag inside of a .text-center div
#   This will round the edges of the image and center the image on the page
# We can also add some centereing classes (mx-auto d-block) and to give some room below the heading (.mt-4)
# Change the image_tag line
#   image_tag(gravatar_url, alt: user.username, class: "rounded shadow mx-auto d-block mt-4")


# Now we want to display the articles this user has created 
# First add a heading below the profile image
# Then below that we want to add the users articles
# Remember that we have access to these through @user.articles
# So we can loop through that and display the cards in the same way that we did for the articles index
# The differences is instead of user Article.all like in the articles index we will user @user.articles
# You can copy the entire card from articles index.html.erb
# Just change the top line from @articles.each do to @user.articles.each do

# Even better we can convert our articles listing code into a partial
# Create a new partial in articles folder called _article.html.erb
# Add the render 'article' tag to the articles index page
#
# Now render the _articles partial in the users show page
# This won't work yet because it doesn't have an @articles instance variable
# What we need to do is make the @article in the card to be something more generic like obj
# Then when we render the pages we can pass in what obj is by adding: obj: @article or obj: @user.articles

# Our render tag in articles index should look like: 
#   <%= render 'article', obj: @articles %>
#
# Our render tage in users show should be:
#   <%= render 'articles/article', obj: @user.articles %>
#
# And our partial should look like:
#   <% obj.each do |article| %>
#     <div class="row justify-content-md-center mt-4">
#       <div class="col-8">
#         <div class="card text-center shadow mb-5 rounded">
#           <h5 class="card-header font-italic">by <%= article.user.username if article.user%></h5>
#           <div class="card-body">
#             <h5 class="card-title"><%= link_to article.title, article_path(article), id: "card-title-text" %></h5>
#             <p class="card-text"><%= truncate(article.description, length: 100) %></p>
#             <%= link_to "View", article_path(article), class: "btn btn-primary"%>
#             <%= link_to "Edit", edit_article_path(article), class: "btn btn-success" %>
#             <%= link_to "Delete", article_path(article), class: "btn btn-danger", method: :delete, data: {confirm: "Are you sure you want to delete this article?"} %>
#           </div>
#           <div class="card-footer text-muted">
#             <small>Created <%= time_ago_in_words(article.created_at) %> ago, edited <%= time_ago_in_words(article.updated_at) %> ago</small>
#           </div>
#         </div>
#       </div>
#     </div>
#   <% end %>

# Now our users show page looks like we want it
# We can make a commit and merge back into our master branch










#==========================================================================#
#            145. Instructor Notes: Show User and Profile Image            #
#==========================================================================#

# To have a profile image associated with an email account you control, add one using the site en.gravatar.com. 
# This will be the globally recognized avatar (gravatar for short) associated with that email address 
# (this step is not necessary to get the functionality working in the app).

# The code changes made in this video can be found here: https://github.com/udemyrailscourse/alpha-blog-6/commit/51c2ec4541a6340910f07211445ac13af21d0c5c

# Summary of changes (actual ode can be found in the commit):

# - Add show action in users controller and a show.html.erb template under views/users.

# - Add gravatar_for as a helper method in app/helpers/application_helper.rb file.

# - Extract the articles listing code from views/articles/index.html.erb file and add it to an _article.html.erb partial within the same folder.

# - Render this partial from both the show and index templates. Be sure to initiate the appropriate instance variable from the users show action.















#============================================#
#            146. Add Users Index            #
#============================================#

# Now we want to add a users index which will list all the users that are signed up for the application
# This will be similar to the articles index

# It will show the username, the profile picture, a view/edit button and a messaging saying how long ago they joined

# The route will be /users this is provided by the users resource 
# If we try to visit it now we get an error because there is no index action
# So we have to add an index method to the users controller and we have to create an index view
# In the index method we want to make our instance variable a list of all of the users in our application
#   def index
#     @users = User.all
#   end

# Now let's add a link to our _navigation partial so that we can access the users index from anywhere
# Add a new item to the drop down that liks to the users index

# Now we want to create cards for each user to show on the page
# This is very similar to the cards in the article view
# It is different enough that we can't use it as a partial but we can use it as a baseline
#
# When complete the users index page should look like this: 
#  <% @users.each do |user| %>
#    <div class="row justify-content-md-center mt-4">
#      <div class="col-8">
#        <div class="card text-center shadow mb-5 rounded">
#          <h5 class="card-header font-italic"> <%= link_to user.username, user_path(user) %></h5>
#          <div class="card-body">
#            <h5 class="card-title">
#              <%= link_to gravatar_for(user, size: 150), user_path(user) %></h5>
#            <p class="card-text"><%= pluralize(user.articles.count, "article") %></p>
#            <%= link_to "View Profile", user_path(user), class: "btn btn-primary"%>
#            <%= link_to "Edit Profile", edit_user_path(user), class: "btn btn-success" %>
#          </div>
#          <div class="card-footer text-muted">
#            <small>Joined <%= time_ago_in_words(user.created_at) %> ago.</small>
#          </div>
#        </div>
#      </div>
#    </div>
#  <% end %>










#==============================================================#
#            147. Instructor Notes: Add Users Index            #
#==============================================================#

# The code changes made in the video can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/a564078908ef85f49b88e31ea12f3fef1d805819

# Summary of changes:

# - Added an index action in the users_controller to list all users using the application.

# - Added an index.html.erb template and filled in the code for the view using the app/views/articles/_article.html.erb partial as a starting template.

# - Added a link to "Bloggers" in the navigation partial which leads to the users index page.















#===========================================#
#            148. Cleanup Layout            #
#===========================================#

# Now let's make some small adjustments to our application

# We are going to add an edit button to the show users page so the user can be edited from viewing the profile
# Add the folowing button below the profile picture:
#   <div class="text-center mt-4">
#     <%= link_to "Edit Profile", edit_user_path(@user), class: "btn btn-success" %>
#   </div>

# Let's also edit the articles listing to link to the users page where it says the user name
# Change the article.user.username embedded ruby to:
#   <%= link_to article.user.username, user_path(article.user), class: "link" if article.user %>
# 
# I also added some css for .link class to style the username link

# Now let's change the redirect for the edit user page
# Right now it redirects to the articles listing page
# We want it to redirect to the user profile page

# Last let's add the associated users gravitar when viewing an indvidual article
# This is in articles/show.html.erb
# We will add the graviatr right after the username and also have it be a link that goes to the user show page 
# update the show page:
#   <div class="card-header font-italic ">by <%= @article.user.username if @article.user%>
#     <%= link_to gravatar_for(@article.user, size: 60), user_path(@article.user) %>
#   </div>










#=============================================================#
#            149. Instructor Notes: Cleanup Layout            #
#=============================================================#

# The code updates made in the video can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/51899366862a4f9509ffad71697af823cd0281d9

# Summary of updates:

# - 'Update your profile' button added to users show page.

# - Redirect updated in users_controller update action to go to the users show page, instead of the articles listing page.

# - Articles index updated by modifying the article partial, the username for users associated with articles displayed turned to links that go to the users' show page.

# - Articles show page modified to display a gravatar image of the user associated with the article.















#====================================================#
#            150. Add Pagination to Views            #
#====================================================#

# Next we are going to add pagination to our views
# Pagination is making limiting the length entries shown on one page
# Then users can go to the next or previous page to see other entries

# We can use pagination on:
#   articles listing page
#   users listing page
#   list of users articles on user show page

# Another benefit is that currently within our methods our instance variables are holding an entire table
# That is ok for now since our tables are small but as more data gets added the variables won't be able to hold enough

# Before we get started make a new branch for adding pagination

# The first thing we have to do is add the will_paginate gem to our application
# Add the following to the gemfile:
#   gem 'will_paginate', '~> 3.1.0'
#
# Then run the following in terminal:
#   $bundle install
#
# Now the gem is added

# Will change our query from getting all to getting a set number of items
#   Table.paginate(page: params[:page], per_page: 30)
# Then in the view we add:
#   <%= will_paginate @variable %>

# First we will add this to the articles page
# Replace the @articles = Articles.all with:
#   @articles = Article.paginate(page: params[:page], per_page: 5)
#
# Then go to the articles index view and render the pagination (right above where we render the list)
#   <%= will_paginate @articles %>

# Now we have the pagination but the styling is way off
# Edit the styling to fix it
# Look at the will_paginate documentation for examples and go off that to edit
# Copy the css of one of the styles you like into our css file
# Then we have to add the appropriate class to where we call the pagination
#   <div class="container">
#     <div class="apple_pagination">
#         <%= will_paginate @articles, :container => false %>
#     </div>
#   </div>
#
# Don't forget to add this both above and below where we render the list of articles so it has pages on both the top and bottom of our list
# Once you are happy with styling we can move on

# Now we can add this same code to the users listing page and the users show page repeating the exact same process
# Besides naming the only difference is the show method will have:
#   @articles = @user.articles.paginate(page: params[:page], per_page: 5)
#
# Since we changed from using @user.articles to using @articles to display make sure you change the arguement you are passing into render

# Pagination is complete
# Make commit and merge










#======================================================================#
#            151. Instructor Notes: Add Pagination to Views            #
#======================================================================#

# The code changes made during the video can be found here: 
#   https://github.com/udemyrailscourse/alpha-blog-6/commit/39f3239e6be61c1d323cb1845aa81a1a54b0c6fb

# The will_paginate gem docs and references can be found here: 
#   https://github.com/mislav/will_paginate

# Summary:

# - Installed the will_paginate gem to the application in order to add pagination to the articles index, users index and users show views.

# - Modified the styling for the pagination based on styling examples provided by the creator of the will_paginate gem here: 
#   http://mislav.github.io/will_paginate/

# - Tested out with 5 objects per page. This can be increased or decreased using the per_page argument in the actions.















#===========================================#
#            152. Add Login Form            #
#===========================================#

# Now we want to build a route and a form to let users login to the app
# This will allow us to restrict access so
#   users only create articles if they are logged in
#   users can only edit and delete their own articles/profile

# First we will need to define a route for /login
# This will lead to a form which accepts an email and password
# If it matches what is in the users table then they can log in

# We are going to use something called sessions 
# This allows us to simulate users being logged in

# Keep in mind this won't have the restful routes in them 
# So we will have to do things differently
# To build the route
# In routes.rb
#   get 'login', to: 'sessions#new'
# 
# What does this do?
# When the login route is requested by a user:
#  our application will run the 'new' method from our sessions controller
#
# We also need to build a route to post to the login route as well so that way we can send data
#   post 'login', to: 'sessions#create'
#
# Now when data is submitted from the /login url (login info) it will be sent to the create method in the sessions controller
#
# We will also need a delete request for /logout so that way we can destroy the current session
#   delete 'logout', to: 'sessions#destroy'

# Now the next step is to build our sessions controller and add methods for the actions we defined in routes.rb
# To get it started it should look like:
#   class SessionsController < ActionController
#     def new
#      
#     end
#  
#     def create
#      
#     end
#  
#     def destroy
#      
#     end
#   end

# Now the next step is to create a login form
# Create app/views/sessions/new.html.erb
# This form will look just like when we create new users or edit new users
# So we can borrow a lot from that
# The form_with line is the main one we have to change
# We can also remove some sections since we don't need both email and username entered
# When finished it should look like this:
#   <h1 class="text-center mt-4">Log In</h1>
#   <div class="container">
#     <div class="row justify-content-center">
#       <div class="col-10">
#         <%= form_with(scope: :session, url: login_path, class: "shadow p-3 mb-3 rounded general-form", local: true)  do |f| %>
#           <div class="form-group row">
#             <%= f.label :username, class: "col-2 col-form-label" %>
#             <div class="col-10">
#               <%= f.text_field :username, class: "form-control shadow rounded form-input", placeholder: "Enter a username" %>
#             </div>
#           </div>
#           <div class="form-group row">
#               <%= f.label :password, class: "col-2 col-form-label" %>
#               <div class="col-10">
#               <%= f.password_field :password, class: "form-control shadow rounded form-input", placeholder: "Enter your password" %>
#               </div>
#           </div>
#           <div class="form-group row justify-content-center">
#             <%= f.submit "Log in", class: "btn btn-success", id: "btn-submit-form" %>
#             <%= link_to 'Cancel and Return to Articles Listing', articles_path, class: "btn btn-danger", id: "btn-cancel form" %>
#           </div>
#         <% end %>
#       </div>
#     </div>
#   </div>

# To test that all of this worked add a byebug to the create action 
# Then try to submit a username and password
# Once it pauses use $params to see what email and password were submitted
#   $params[:session][:email]
#   $params[:session][:password]
#
# Since we are getting what we input returned we know that we can start using that to check if login credentials were valid










#=============================================================#
#            153. Instructor Notes: Add Login Form            #
#=============================================================#

# The code changes made during the previous video can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/386d8f6a61fa9ab415c65baa63d0ca1225f6c32f

# Summary of changes:

# - Added routes for login - new, create and destroy (to represent login form, logging in a user and logging out a user).

# - Added a sessions controller with the new, create and destroy actions.

# - Added a sessions folder under app/views and created a new.html.erb template to display the login form.















#=============================================================#
#            154. Create and Destroy User Sessions            #
#=============================================================#

# Now that we can collect login information from the user we will authenticate it
# And log the user into a logged in state

# We will use something called sessions to represent a logged in state

# First we want ot verify that the username and password that get passed in through the form
#  match the credentials for a verified person

# In rails console we would want to do something like this
#   $user = User.find_by(username: "user2")
#
# In our actual application we would be passing in params[:session][:email] instead of the email string
# If this doesn't return a result we already know that the login is invalid

# Let's add this to our create action in our sessions_controller.rb
# Since our email addresses are stored downcased we want to downcase the user entry before running the search
# Otherwise it might not find a result when it should 
# When finished the line should look like:
#   user = User.find_by(email: params[:session][:username].downcase)
#
# now we can decide what to do if that user is found or not by using an if user statement


# Let's jump in the console and see how we can verify the password
# Remember earlier we used the .authenticate method
# We can do that again with the user object we got from the search
#   $user.authenticate("password")
# 
# If the password is correct it will return the user object
# If it is incorrect it will return false
# So we can run the authenticate method alongside the if block if the user username is found
# Then if a user object is returned from that method we know that the password was correct and the user was valid

# Let's handle if it wasn't valid first
# We want to do 2 things
#   render the new page again
#   show a flash message if something was wrong
# Add those 2 things to the if/else block
# By this point the create method should look like:
#   def create
#     user = User.find_by(username: params[:session][:username].downcase)
#     if user && user.authenticate(params[:session][:password])
#     
#     else
#       flash.now[:alert] = "There was something wrong with your login details"
#       render 'new'
#     end
#   end
#
# Wait why flash.now when we were using flash notice before?
# That's because flash.notices get stored and we recall them when we need to
# Flash.now doesn't get stored and instead gets shown on the same page 
# Since we aren't redirecting and are just rendering the page again this is what we need

# So what do we want to do when we have an authenticated user?
#   Display a message saying login was successful
#   Redirect to the users show page
# Since we are redirecting to the users show page we need to use flash[:notice] this time instead of flash[:now]
# Now the create method should look like this:
#   def create
#     user = User.find_by(username: params[:session][:username].downcase)
#     if user && user.authenticate(params[:session][:password])
#       flash[:notice] = "Login Was Successful"
#       redirect_to user
#     else
#       flash.now[:alert] = "There was something wrong with your login details"
#       render 'new'
#     end
#   end

# We are authenticating and verifying that what was entered matches somethining in the databse but we aren't doing anything with that
# We need to create a "logged in" session to make it mean anything
# Sesions allow the app to maintain user specific states
#   One state could be an unregistered user 
#     can only view apps and other users
#   Another state would be a logged in user
#     can edit and delete their own articles
# We need to do that in the create action 
# Rails provides a session object which users can access using a session instance method
# The session instance method can be called simply with "session"
# This object can store data about the user that we would like to track while they are on the site
# We are going to do this with:
#   session[:user_id]
# We can also set this to the user who was just authenticated so they can remain in a logged in state until they log out (using destroy action)
# Add this to the top of if/else block in the create method:
#   session[:user_id] = user.id
#
# We are only storing the user.id but we can store other things if we would like
# All sessions store a cookie as a unique id for each session
# This will store the data in the browser itself for the user
# Session encrypts this data and is signed so it is tamper proof
# Later we will session[:user_id] to get the logged in user's id when we need to

# Now let's add a login button to our layout
# In our _navigation partial
# Add a new item to the navbar that links to the login page
# Add the following below the dropdown:
#   <li class="nav-item">
#     <%= link_to "Login", login_path, class: "nav-link"%>
#   </li>
#
# Now we should have a login button on our navbar

# Now how do we handle logout?
# We simply need to set the session[:user_id] to be nil
# In the destroy method of the sessions_controller.rb add the following:
#   session[:user_id] = nil
#
# Also add a flash notice saying user was logged out
# And redirect to the homepage
# When finished the destroy method should look like this:
#   def destroy
#     session[:user_id] = nil
#     flash[:notice] = "User was logged out"
#     redirect_to root_path
#   end

# Now to test it let's add another button to the navbar for logout
#   <li class="nav-item">
#     <%= link_to "Logout", logout_path, class: "nav-link", method: :delete %>
#   </li>










#===========================================================================#
#            155. Instructor Notes: Create&Destroy User Sessions            #
#===========================================================================#

# The code changes made during the previous video can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/95159f6af119fa4edde62172b85e1e51da9c5a3f

# You can read more about Sessions and how Rails utilizes them here: 
# https://guides.rubyonrails.org/action_controller_overview.html#session

# Summary:

# -  Completed create and destroy actions for sessions controller to log users in and out.

# - Added log in and log out links to navigation partial.















#==========================================================#
#            156. Authentication Helper Methods            #
#==========================================================#

# We will use helper methods to determine whether some items or buttons are available or not based on if the user is logged in

# We will add these to the application helper in app/helpers/application_helper.rb
# We are going to create 2 methods
#   current_user
#     This will return the details of the user who is logged in
#     Remember we have access to the current user id from the session[:user_id]
#     If we need to retrieve details of a user this is the method we will use
#   logged_in?
#     This will check if we have a user logged in currently

# Now let's build these two methods
#   Current user
#     We can access the id of the user who is logged in with session[:user_id]
#     We want to see if that session user_id exists
#     If it does we want to receive the user objects in the users table
#     We are going to implement a Monadic pattern
#     This is done by setting an instance variable on one side of ||=
#     on the other side is what that variable will be set equal to
#      BUT ONLY IF THE VARIABLE DOES NOT ALREADY HAVE A VALUE
#      If the variable already has a value it will just use the value it is already assigned
#     
#   logged_in?
#     This will run the current user method and return true or false
#     If current_user has a value (a session user_id exists)
#       Then logged_in? will return true
#     If current_user does not have a value (session user_id doesn't exist)
#       logged_in? returns false
#     We can turn another method into a boolean in rails with !! before method name
#       (ex: !!current_user)
#
# The two methods should look like this when complete:
#  def current_user
#    @current_user ||= User.find(session[:user_id]) if session[:user_id]
#    end
#  end
#
#  def logged_in?
#    !!current_user
#  end

# Let's test this out to make sure it works
# To do that we will make a change to the navigation bar
# We will make it show login/logout link in the navbar based on whether the user is signed in or not
# In the navigation partial
# We want to add an if block
#   If logged_in? returns true
#     show the logout link in the navbar
#   If logged_in? returns false
#     show the login link in the navbar
# 
# Edit the navbar login/logout section to be the following:
#   <% if logged_in? %>
#     <li class="nav-item">
#       <%= link_to "Logout", logout_path, class: "nav-link", method: :delete %>
#     </li>
#   <% else %>
#     <li class="nav-item">
#       <%= link_to "Login", login_path, class: "nav-link" %>
#     </li>
#   <% end %>

# Now we want to add a section to the navbar that shows either
#   the username (as a dropdown with view/edit buttons?) of the current user
#   a signup link if there is not a user logged in 
# We are going to follow a similar pattern as the previous changes to the navbar
# Now the if block should look like this:
#   <% if logged_in? %>
#     <li class="nav-item dropdown">
#       <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
#         <%= current_user.username %>
#       </a>
#       <div class="dropdown-menu" aria-labelledby="navbarDropdown">
#         <%= link_to "View Profile", user_path(current_user.id), class: "dropdown-item"  %>
#         <%= link_to "Edit Profile", edit_user_path(current_user.id), class: "dropdown-item"  %>
#         <div class="dropdown-divider"></div>
#         <%= link_to "Logout", logout_path, class: "dropdown-item", method: :delete %>
#       </div>
#     </li>
#  
#   <% else %>
#     <li class="nav-item">
#       <%= link_to "Login", login_path, class: "nav-link" %>
#     </li>
#     <li class="nav-item">
#       <%= link_to "Sign Up", signup_path, class: "nav-link" %>
#     </li>
#   <% end %>
#
# We still have one small issue

# If a user signs up they are not logged in when they sign up
# We want to run the sign in process when a user signs up for the website
# To do that we need to go in the users_controller
# edit the create method to also sign in
# We can use the line from the create controller that creates a session to also create a session for the user id that was just generated
# The only difference is we change to an instance variable since that is what we are working with in the create method:
#   session[:user_id] = @user.id
# 
# Now the create method should look like this:
#   def create
#     @user = User.new(user_params)
#     if @user.save
#       session[:user_id] = @user.id
#       flash[:notice] = "Welcome to the Alpha Blog #{@user.username}, you have successfully signed up"
#       redirect_to articles_path
#     else
#       render 'new'
#     end
#   end










#==================================================================#
#            157. Instructor Notes: Auth Helper Methods            #
#==================================================================#

# The code changes made during the previous video can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/d154a5b0c53a05384e036623b4f8c4c56abc0e4b

# Summary of changes:

# - Added current_user and logged_in? helper methods.

# - Modified the navigation partial and utilized these methods to display links based on logged in state.

# - Modified the users controller create action so users' are logged in once they sign-up.

# - Added set_user method and used it as before_action for show, edit and update actions in users controller.














#=================================================================#
#            158. Controller Methods as Helper Methods            #
#=================================================================#

# Say we have a user logged in user and they create an article
# If we view the created article it will show it was made by the wrong user 
# This is because we hardcoded the user earlier since we did't have the session user_id available yet
# We need to go back to the articles_controller 
# change it from assigning the first user in the databse
#  to assigning the session user_id as the user
# We will get this id from the current_user method in the application_helper we wrote last lesson
# We have to make that method available to the articles_controller
# To do that we can add current_user to the application_controller which all of our other controllers have access to
# Remove the current_user method from application_helper and put it in application_controller
#
# Now that method is available to the articles_controller and we can change this line:
#   
#   @article.user = User.first
#   to
#   @article.user = current_user
#
# Now when we make an article it will assign it to whoever actually wrote the article

# However since it is in the application_controller it is only available to controllers
# In order to make it available to views we have to let the applicaton_helper know that it is allowed to use it
# To do that add to the top of application_controller
#   helper_method :current_user
#
# This will make the current user method available to helpers (and therefore views again)

# Let's do the same for the logged in method since we will want to use it in both views and controllers
# For example if a user is logged in and they click the logo button we want to redirect them to the articles index instead of the signup page
# To do that add logged in to the application_controller and include it as a listed helper method within there
#   (make sure you remove it from application_helper)
#
# Then in the pages_controller for home method
# We want to redirect to the articles index if the user is logged in
# So we can write that like:
#   redirect_to articles_path if logged_in?
#
# And now clicking the logo as a logged in user will load the articles path










#====================================================================================#
#            159. Instructore Notes: Controller Methods as Helper Methods            #
#====================================================================================#

# Code changes made in the previous video can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/2a0d5136856be5366655e1f24670b970a402d007

# Summary:

# - Moved the current_user and logged_in? authentication methods from application helper to application controller and declared them as helper methods so they can be used in views as well.

# - Updated the create action in articles controller so the logged in user is associated with the article being created instead of hardcoding the user.

# - Updated pages controller home action (root route) to redirect to articles index page if users are logged in.















#=====================================================#
#            160. Restrict Actions From UI            #
#=====================================================#

# Now we will continue to restrict access based on if a user is logged in
# More importantly WHO the logged in user is

# Right now articles can be edited or deleted if a user is not logged in\
# We do not want that we only want users to be able to edit and delete their own articles
# We will restrict these actions only available to matching users

# First let's login as a user that can only has a couple of articlces

# In the _articles partial
# We will have to check if a user is logged in and if they are the current user for the article card being generated
# If the are the current user than the edit and delete buttons should show
# Display the view articles button regardless of who the user is or if they are logged in
#
# Simply put the two buttons we want to hide inside of an if block
# The if block should run both the logged_in and current_user and check if the article.user_id == user.id
# When complete it should look like this:
#   <% if logged_in? && article.user == current_user %>
#     <%= link_to "Edit", edit_article_path(article), class: "btn btn-success" %>
#     <%= link_to "Delete", article_path(article), class: "btn btn-danger", method: :delete, data: {confirm: "Are you sure you want to delete this article?"} %>
#   <% end %>
#
# This will check if a user is logged in
# If they are logged in it will see if the user associated with the article is matches the current user (the one stored in session)
# If they match then it will display the edit and delete buttons
#
# Note that the _articles partial is also associated with the users show page
# This means the buttons should work like they do in the index on the show page as well
# So if a user is looking at a list of all of their own articles then they should be able to view/edit/delete any/all of them
#  If they are looking at another users show page (article list) then they will only be able to view

# We still have to restrict the action on the individual articles show page
# We will have to do the same thing as above in the articles show view
# Place the two buttons inside an if block like this:
#   <% if logged_in? && @article.user == current_user %>
#     <%= link_to "Edit", edit_article_path(@article), class: "btn btn-success" %>
#     <%= link_to "Delete", article_path(@article), class: "btn btn-danger", method: :delete, data: {confirm: "Are you sure you want to delete this article?"} %>
#   <% end %>
#
# Now users can't interact with any articles they shouldn't be able to

# Now let's edit the users index so that users can only edit their own profile
# Continue doing the subbing out the vairables where appropriate but following the same pattern
# For any other links such as create an article
# Don't worry about the navbar yet we will get into that next lesson










#=======================================================================#
#            161. Instructor Notes: Restrict Actions From UI            #
#=======================================================================#

# Code updates made during the last video can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/2a6af60ee69eb0e4baba9f880120de24cc331e67

# Summary of changes:

# - Added logged in and current user == article user based restrictions to articles/_article.html.erb partial, articles/show.html.erb, users/index.html.erb and users/show.html.erb.















#===============================================================#
#            162. Modify Navigation Based on Helpers            #
#===============================================================#

# First in the naviagtion bar we are going to remove the "Create new article" option for users who are not logged in

# Add the create new article dropdown listing into a logged_in if block

# Fix the navigation bar until it shows the correct options for logged in and logged out users
#  make sure any links work and go to the relevant pages

# Now we still have one big problem
# Currently when we view a users profile (if it is not the signed in user) there is no button to edit that profile
# However if a user (logged in or not) goes to another users profile and adds /edit to the end of the url they still have access to that route
# This also works for articles

# We need to edit the controllers so that those routes are unavailable to anyone except the relevant user
# This will be covered in the next lesson










#================================================================#
#            163. Instructor Notes: Modify Navigation            #
#================================================================#

# Code updates made during the previous video can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/89704463c4b7c7d42413e8638d90866eb739f341

# Summary of changes:

# - Restricted the new article creation option in the navigation menu to logged in users only.

# - Added a dropdown with users profile action links.















#==================================================================#
#            164. Restrict Controller Actions - Articles           #
#==================================================================#

# We are going to start with the articles controller

# As a logged out user there is no button to create a new article anywhere in the app
# However if they were to navigate to articles/new they would be able to access the form
# We are going to restrict this in our code by adding a require_user method
# That way create an article won't be accessible if there is no user logged in
# We will add the require_user method to the application controller since other controllers will need to access it as well

# application_controller
#   require_user
#     def require_user
#       if !logged_in?
#         flash[:alert] = "You must be logged in to perform that action"
#         redirect_to login_path
#       end
#     end
#
#     This is a method that we will run on any action that requires a user to be logged in
#     If the user is not logged in it will redirect the previous action to the login page
#     It will also show a message saying the user must be logged in to do whatever they were trying to do

# Now let's use this new method in our articles controller
#
# There are several different methods that need a user to be logged in to perform it
#   new
#   edit
#   create
#   update
#   destroy
# 
# This is everything except the show and index
# So we are going to use a before action on all of those methods
# Right below the other before action (so the other one runs first)
# Instead of using the only: option we can use the except: action and list the index and show
# the added before action line should look like:
#   before_action :require_user, except: [:show, :index]
#
# We want to use except because it is more restrictive 
# that way we don't forget to add an action to only: and the people can access methods they shouldn't be able to

# Now there are a couple methods we want to restrict even more
# For edit, update, and destroy only the user who created the article can perform these actions
#
# We will need to add a new method to the articles_controller
# To check if the current user is the owner of the object they are trying to change
# Right now if a user is not logged in they cannot access the edit article form
# However if a user is logged in they can still edit any article
# Since this is specific to articles we can add this to the articles_controller as a private message
# require_same_user 
#   def require_same_user
#     if current_user != @article.user
#       flash[:alert] = "You can only edit or delete your own article"
#       redirect_to @article
#     end
#   end
#
# We want to run this method after require_user since require user runs logged_in?
#  and that must be run before current_user (which is in this method)
# But we also want to run it before any of the controller actions
# We can do that by adding before_action below our before_action :require_user
# It should look like this:
#   before_action :require_same_user, only:[:edit, :update, :destroy]










#=============================================================================#
#            165. Instructor Notes: Restrict Controller - Articles            #
#=============================================================================#

# Code changes/updates made during the previous video can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/feef5054f1dacdd4d3fcbab91325cb900b5538ce

# Summary of changes:

# - Added require user method in application controller.

# - Added require same user private method in articles controller.

# - Used the two methods defined above as before_action methods in a few actions to restrict activities in the articles controller.















#================================================================#
#            166. Restrict Controller Actions - Users            #
#================================================================#

# Right now if not logged in you can view a users profile and there is no button to edit
# However if they add /edit to the url they are allowed to edit that profile
# We want to make it so that users can only edit their own profile (just like with articles)

# We will do the same thing for Users that we did for Articles
# First we will add the before_action require_user on the edit and update actions
#   before_action :require_user, only: [:edit, :update]
#
# Now unregistered users can't edit any profiles
# We have to make it so users can only register their own profiles
# We will do the same thing as in the articles and create a require_same_user method
# require_same_user: (private method)
#   def require_same_user
#     if current_user != @user
#       flash[:alert] = "You can only edit your own account"
#       redirect_to @user
#     end
#   end
#
# Then we will run this method before the edit and update methods
#   before_action :require_same_user, only: [:edit, :update]










#=================================================================================#
#            167. Instructor Notes: Restrict Controller Actions - User            #
#=================================================================================#

# Code changes made during the previous video can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/419ae8a9c26bb4895966816cb0be46bb0a306570

# Summary of changes:

# - Added require_same_user method to users controller.

# - Used require_same_user and require_user methods to restrict certain actions in the users controller.















#========================================#
#            168. Delete User            #
#========================================#

# Now we want to give user the ability to delete their own account
# We also want all of their articles to be deleted as well

# First create a user named i-will-delete and an article for them for us to test on

# We want to delete the articles because we do not want stray articles that do not have users associated with them
# These articles would never be able to be deleted without a big cleanup since they don't have users approved to delete them

# The lesson adds the delete account button in the navbar
# I am going to add it to the edit account page of the user profile
# We can use the following if statement to show a delete account button on the profile information form partial only if
#   the user is logged in
#   the user is on their own edit page
#     they shouldn't be able to access someone else's edit page at this point but just in case this will make sure they will not get a delete button]
# Use the following: (users/_form.html.erb)
#   <% if logged_in? && @user == current_user %>
#     <%= link_to  'Delete Profile', user_path(current_user), class: "btn btn-danger", id: "btn-cancel-form", method: :delete, data: {confirm: "Are you sure you want to delete your account?"}%>  
#   <% end %>

# Now we have to add a delete method to the users controller to delete the user
# We want to identify the user who should be destroyed
# Since we will need to know who the user being targetted is (the id in the url)
# We can run set_user before running destroy method so add :destroy to the before_action :set_user array
#
# Then we have to run .destroy on the current user with @user.destroy
# We also have to get rid of the session[:id] and set to nil or rails will be mad that user does not exist but is logged in
# Then make a flash notice telling the user their account and articles have been destroyed 
# Finally redirect_to the home path
# When finished the destroy method should look like this:
#   def destroy
#     @user.destroy
#     session[:user_id] = nil
#     flash[:notice] = "Account and all associated articles have been successfully deleted"
#     redirect_to root_path
#   end
#
# We also have to add the destroy method to the require_user and require_same_user before_action methods arrays

# Now to the user will be deleted (You can test on an user that hasn't written any articles)

# Now we want to make sure that all of their articles are deleted with their account
# We can do this in the users model (app/models/users.rb)
# We can add:
#   dependent: :destroy
# 
# To the end of the line that associates users and articles (has_many)
# When finished it should look like this:
#   has_many :articles, dependent: :destroy
#
# This willd destroy all of the articles that are linked to that user when the user is destroyed 










#==========================================================#
#            169. Instructor Notes: Delete Uesr            #
#==========================================================#
# Code changes made during the previous video can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/dd412a935ae37bd501f1e69b663fba11df6d64f5

# Summary of changes:

# - Added functionality for users to delete their own accounts using a destroy method in the users controller.

# - Added a link to delete account to the users' profile dropdown navigation option.

# - Utilized a couple of existing methods (as before_action methods) to secure the newly created destroy action at controller level.















#================================================================#
#            170. Add Admin User Functionality: Intro            #
#================================================================#

# Now we will implement an admin user functionality in our application
# This will allow certain users to perform actions that other users cannot perform
# This is a basic permissions functionality
# It will allow different levels of users different access to different features

# We are going to use a simple true false value to the users table 
# If a user is an admin they will have true in the admin column
# Everyone else will have false
# We will initiate this column with a default value of false

# First is we have to generate a migration file to add this column
#   $rails generate migration add_admin_to_users

# Now we can edit this migration file to add the admin column 
# Edit the change method to match the following:
#   def change
#     add_column :users, :admin, :boolean, default: false
#   end
#
# This will add a new column to the users table
# The column will be called admin and it will hold a boolean
# Then it will set a default value (for existing and created users) to false

# Save migration file
# Now run the migration file
#   $rails db:migrate

# We can check that it updated in the schema file
# We can now see the line:
#   t.boolean "admin", default: false 
#
# So we know it added correctly

# How do we know if a user is an admin?
# We can check in rails console:
#   $user = User.first
#   $user.admin?
#   =>false
#
# How do we make a user an admin?
#   $user.toggle!(:admin)
#   $user.admin?
#   =>true










#================================================================#
#            171. Instructor Notes: Add Admin - Intro            #
#================================================================#

# Code changes made in the previous video can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/6f18eb452514de8d6f854e05faa3bc306adecd26

# Please note: Only the migration file that was generated was updated, 
# the rest of the updates to the schema and creation of the migration file itself happen as other commands are executed 
# (they don't need to be created/updated manually).

# Summary of changes:

# - Generated migration file to add admin field to users table, with a default value of false for all users.

# Whether a user is admin or not can be tested by first getting a user object in the rails console and checking user.admin? from there.

# To switch a user to an admin user you can use the following command in the rails console (assuming you have already selected a user object):

# user.toggle!(:admin)















#===============================================================#
#            172. Add Admin to Views and Controllers            #
#===============================================================#

# Now we are going to add some functionality to admin users that are not available to regular users
# We will add these in the views and controllers
# To start we are going to add some admin text next to the username
# We will be using the user that we made admin last lesson (user 2)
# Where we display the users name in the navigation bar lets add an admin title 
# Add this to put the admin title next to the username: (This also let's us style the title to different colors)
#   <% if current_user.admin? %>
#     <span class="admin-title">[admin]</span>
#   <% end %>
#
# You can see on the admin user the title now shows (color in css if you want)
# Login as a regular user and there is no title

# Now we want to give admins the ability to edit or delete articles created by other users
# To do that we wil have to edit the _article partial
# Right now the partial is only checking for if the session id matches the article.user_id
# We can add an or that will also show the edit/delete buttons if current_user.admin? is true
# Change the if statement controlling those buttons to:
#   <% if logged_in? && (article.user == current_user || current_user.admin?) %>
#
# Now it will show if a user is logged in and the article belongs to the current user
#  OR if the user is logged in and the user is an admin
# Now we can see the edit and delete options showing up for every article regardless of owner as an admin

# However the actual methods behind these buttons are still restricted in the controller
# So we have to go to the articles_controller and edit the require_same_user method
# We can simply add:
#   && !current_user.admin?
# The method should look like:
#   def require_same_user
#     if current_user != @article.user && !current_user.admin?
#       flash[:alert] = "You can only edit or delete your own article"
#       redirect_to @article
#     end
#   end
#
# Now the admin will be able to do any method in the articles table even if it requires same user

# Now we have to allow admin users to view the buttons on the show page (they already have access to the methods behind them)
# Same as last time:
#   <% if logged_in? && (@article.user == current_user || current_user.admin?) %>
#
# Now the buttons are visible on the show page

# Now we want to give admins the ability to delete users from the users index page
# But we don't want regular users (same user or not) to be able to do that 
#  that should only be available to them in edit
#
# We can also add this to the users show page for admins

# First the index view for users:
#   <% if logged_in? %>
#     <% if user == current_user %>
#       <%= link_to "Edit Profile", edit_user_path(user), class: "btn btn-success" %>
#     <% end %>
#     <% if current_user.admin? %>
#       <%= link_to "Delete User", user_path(user), class: "btn btn-danger", method: :delete,
#       data: {confirm: "Are you sure you want to delete this user account and all associated articles?"} %>
#     <% end %>
#   <% end %>
#
# Now for a regular user they will get an edit button for their own account on the users listing
# An admin will see a delete button on all accounts 

# Now for the user show page add a delete button for admin
# It will be just like above

# Now the problem that we have is that these buttons are only at the view layer
# If an admin tries to use them they will get stopped by the user_controller rquire_same_user method
# We have to edit this method just like in articles to allow for admins to not get redirected

# But now a weird thing happened
# When an admin deletes the account the account is deleted along with it's articles
# However the admin is then logged out of their account and must log back in
# That's because in the destroy method we set session[:user_id] to nil
# This causes a logout regardless of who is logged in
# We want to add some logic to only clear sesion[:user_id] if it matches the user being destroyed
# Edit the session[:user_id] = nil:
#   session[:user_id] = nil if @user == current_user
#
# This logic will also allow the admin to delete their own account 

# Now we have a pretty fully built application










#==============================================================================#
#            173. Instructor Notes: Add Admin Views and Controllers            #
#==============================================================================#

# Code changes made during the previous video can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/f59be3d440cb36a0a321976dfe4413d7a67f6921

# Summary of changes:

# - Navigation partial updated to display "(Admin)" for admin user accounts.

# - Article actions (edit and delete) made available to admins for all articles in both for articles index (rendering article partial) and articles show views.

# - Added ability for admin users to delete other user accounts through the users index page.















#=======================================================#
#            174. Assignment - Alert Message            #
#=======================================================#

# Now for an assignment
# Throughout the application there are flash messages
# They show up with alert-success in bootstrap
# All of the alert messages are in green even if they are negative
# We should display these in red
# We have used flash with [:alert] and [:notice] throughout our app
# We want to set up an if statement in _messages so that
#  depending on the type of flash message the color will be appropriate




####    MY SOLUTION    ####

# Add the following to the application_helper.rb
#   def bootstrap_class_for(flash_type)
#     case flash_type
#       when "alert"
#         "alert-danger"
#       when "notice"
#         "alert-success"
#       else
#         flash_type.to_s
#       end
#   end

# Then update the class where flash messages are rendered to be:
#  <div class="alert <%= bootstrap_class_for(name) %> alert-dismissible fade show" role="alert">

# Then set styles in css for alert-danger and alert-success if you want to overwrite bootstrap default










#==================================================================#
#            175. Instructor Notes: Assignment Solution            #
#==================================================================#
# Solution code to the assignment can be found here: 
# https://github.com/udemyrailscourse/alpha-blog-6/commit/70e4fe8682b791be8365ba45545928da7acb6dec

# Summary: Embed ruby code in place of hard-coded 'success' in the messages partial. 
# 'success' is returned if the key ('name') from the flash hash is 'notice' and 'danger' is returned otherwise. 
# This gives the alert message the green or red color depending on the notice type.
















#==============================================================#
#            176. Prod Deploy and Wrap up Section 6            #
#==============================================================#

# Now we are ready to push our application to production

# Make sure all changs have been save, commited, and pushed to remote repo

# Push the repo to heroku
#   $git push heroku master

# Now we must run our migrations so all of our databse changes are reflected in heroku
#   $heroku run rails db:migrate

# Right now the articles in our production database don't have any users asociated with them so we are goin to delete them
# To do that we will need to access our production application's rails console
# We can do that in the terminal
#   $heroku run rails console

# Then we can see that there are no users on this app (since we created users since we last deployed)
#   $User.all

# You can see that only the articles we made last time we pushed to production are in here
#   $Article.all

# Then we can delete all of the old articles
#   $Article.delete_all

# Now we want to sign up a user who we want to make the admin

# Once we have the account made we can make the user we just created an admin
#   $User.all
#   $user = User.first
#   $user.toggle!(:admin)

# Reload the page as the admin user and you should see that you know have admin permissions!










#============================================#
#            Section 6. Complete!            #
#============================================#